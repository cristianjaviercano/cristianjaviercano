# Gradio Tool to Create Solutions

## introduction

Gradio is an _open-source_ Python library designed to simplify the creation of intuitive and interactive user interfaces for machine learning models. In research and development, particularly in fields like industrial engineering, the ability to rapidly deploy and share a model for real-world testing and validation is crucial. Gradio bridges the gap between a functional machine learning model, often resident within a Jupyter Notebook or a Python script, and an accessible web application, thereby facilitating immediate feedback and collaboration without necessitating expertise in web development (Abid et al., 2019).

### Theoretical Framework

_**The fundamental theoretical**_ model of Gradio is based on mapping a Python function to a user interface. This function can be any callable Python object, ranging from a simple mathematical operation to a complex machine learning model's prediction method. Gradio abstracts the complexities of front-end and back-end communication, client-side rendering, and server management.

#### The core abstraction consists of three main parts:

1. _**The Function (`fn`):**_ This is the computational core that processes inputs and produces outputs. In an industrial engineering context, this could be a predictive maintenance model, a quality control image classifier, or a simulation for process optimization.
2. _**Inputs:**_ These are user interface components that gather data from the user. Gradio provides a rich set of pre-built input components, such as text boxes, sliders, image uploaders, and dropdown menus.
3. _**Outputs:**_ These are components that display the results generated by the function. Outputs can range from simple text to complex data visualizations like plots, highlighted text, or images.

{% hint style="warning" %}
Gradio essentially wraps the provided function in a web server and automatically generates a user interface based on the specified input and output components. This allows for real-time interaction, where user inputs are passed to the function, and the returned values are immediately rendered in the output components.
{% endhint %}

#### Architectural Components and Functionality

Gradio's architecture is built around two primary classes: `Interface` and `Blocks`.

**`gradio.Interface`**

The `Interface` class is a high-level abstraction that is sufficient for a wide range of use cases. It is configured with the three core elements: `fn`, `inputs`, and `outputs`.

* `fn`: The Python function to be demonstrated.
* `inputs`: A list of `gradio` input components corresponding to the arguments of the function.
* `outputs`: A list of `gradio` output components corresponding to the values returned by the function.

**`gradio.Blocks`**

For more complex and customized layouts, the `Blocks` class offers a lower-level, more flexible approach. With `Blocks`, components can be arranged explicitly using layout elements like rows and columns. It allows for the creation of multi-step workflows, where the output of one function can serve as the input to another, enabling the construction of sophisticated data applications and dashboards.

### **Key Features for Researchers**

_**Gradio**_ offers several features particularly beneficial for the research community:

* **Interactivity and Real-Time Feedback:** Allows for immediate testing of model responses to a wide variety of inputs.
* **Shareability:** Generated interfaces can be shared via a public URL, enabling easy collaboration with colleagues or stakeholders who can interact with the model from their own devices.
* **Component Variety:** Supports a wide array of data types including text, numbers, images, audio, video, dataframes, and plots.
* **Integration**: Seamlessly integrates with major machine learning libraries such as Scikit-learn, TensorFlow, and PyTorch.
* **Embedding: I**nterfaces can be directly embedded within Jupyter Notebooks, facilitating a cohesive research and development environment.

### Example One: Application in an Industrial Engineering Context

$$f$$:: Consider a scenario in quality control where a machine learning model has been trained to classify products as 'Acceptable' or 'Defective' based on sensor readings (e.g., temperature and pressure). Gradio can be used to create a simple interface for operators or engineers to test the model with new data points.

The model $$f$$ could be a trained classifier, such as a logistic regression, support vector machine, or a neural network, which computes the probability of a defect and classifies based on a threshold.

#### Python Implementation:

Assuming a simple logistic regression model has been trained and saved, the following Python code using Gradio demonstrates how to create an interactive interface for it.

```python
import gradio as gr
import numpy as np
# A mock predictive model for demonstration purposes.
# In a real scenario, one would load a pre-trained model file (e.g., a pickle file).
# Let's assume the model's decision boundary is a simple linear one.
# For example, Defect if (0.5 * temperature + 0.8 * pressure) > 100
def predict_quality(temperature, pressure):
    """
    A simple mock function to predict product quality based on sensor data.
    """
    # This simulates the model's prediction logic
    score = 0.5 * temperature + 0.8 * pressure
    if score > 100:
        return "Defective"
    else:
        return "Acceptable"

# Define the Gradio interface
iface = gr.Interface(
    fn=predict_quality,
    inputs=[
        gr.Slider(minimum=50, maximum=150, value=100, label="Temperature (°C)"),
        gr.Slider(minimum=80, maximum=120, value=100, label="Pressure (kPa)")
    ],
    outputs=gr.Textbox(label="Predicted Quality"),
    title="Manufacturing Quality Control",
    description="An interface to test the predictive maintenance model. Adjust the sliders to simulate sensor readings and predict product quality."
)

# Launch the interface
# This will start a local web server and can be accessed in a browser.
# In a Jupyter Notebook, the interface will be displayed inline.
iface.launch()
```

{% hint style="warning" %}
This script creates a web interface with two sliders for temperature and pressure and a textbox to display the model's prediction. An engineer can interact with the sliders to see how different operating conditions affect the predicted quality, providing an intuitive way to understand and validate the model's behavior.
{% endhint %}

***

## using VS Code

## Step 1: Environment Setup (Prerequisites)

Before writing any code, it is crucial to prepare a clean and well-configured development environment.

1. Install Python and VS Code: Ensure that a recent version of Python is installed on your system. You will also need to have Visual Studio Code installed.
2. Install the Python Extension for VS Code: Inside VS Code, navigate to the Extensions tab (Ctrl+Shift+X), search for the official Python extension by Microsoft, and install it. This extension provides essential features like linting, debugging, IntelliSense, and environment management.

#### # Step 2: Project and Virtual Environment Setup ⚙️

For any new project, creating a virtual environment is a best practice. It isolates your project's dependencies, preventing conflicts with other projects.

1. Create a Project Folder: On your file system, create a new folder for your application. For example: `gradio_qc_project`.
2. Open the Folder in VS Code: Launch VS Code and go to `File > Open Folder...` to open the directory you just created.
3. Create the Virtual Environment: Open a new terminal within VS Code (`Terminal > New Terminal` or `Ctrl+Shift+``). Run the following command to create a virtual environment named` venv\`:

{% hint style="info" %}
this phase assures you not to have conflicts with other projects - crc
{% endhint %}
