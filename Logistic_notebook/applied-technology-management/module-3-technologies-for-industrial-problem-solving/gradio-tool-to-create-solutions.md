---
icon: python
---

# Gradio Tool to Create Solutions

## introduction

Gradio is an _open-source_ Python library designed to simplify the creation of intuitive and interactive user interfaces for machine learning models. In research and development, particularly in fields like industrial engineering, the ability to rapidly deploy and share a model for real-world testing and validation is crucial. Gradio bridges the gap between a functional machine learning model, often resident within a Jupyter Notebook or a Python script, and an accessible web application, thereby facilitating immediate feedback and collaboration without necessitating expertise in web development (Abid et al., 2019).

### Theoretical Framework

_**The fundamental theoretical**_ model of Gradio is based on mapping a Python function to a user interface. This function can be any callable Python object, ranging from a simple mathematical operation to a complex machine learning model's prediction method. Gradio abstracts the complexities of front-end and back-end communication, client-side rendering, and server management.

#### The core abstraction consists of three main parts:

1. _**The Function (`fn`):**_ This is the computational core that processes inputs and produces outputs. In an industrial engineering context, this could be a predictive maintenance model, a quality control image classifier, or a simulation for process optimization.
2. _**Inputs:**_ These are user interface components that gather data from the user. Gradio provides a rich set of pre-built input components, such as text boxes, sliders, image uploaders, and dropdown menus.
3. _**Outputs:**_ These are components that display the results generated by the function. Outputs can range from simple text to complex data visualizations like plots, highlighted text, or images.

{% hint style="warning" %}
Gradio essentially wraps the provided function in a web server and automatically generates a user interface based on the specified input and output components. This allows for real-time interaction, where user inputs are passed to the function, and the returned values are immediately rendered in the output components.
{% endhint %}

#### Architectural Components and Functionality

Gradio's architecture is built around two primary classes: `Interface` and `Blocks`.

**`gradio.Interface`**

The `Interface` class is a high-level abstraction that is sufficient for a wide range of use cases. It is configured with the three core elements: `fn`, `inputs`, and `outputs`.

* `fn`: The Python function to be demonstrated.
* `inputs`: A list of `gradio` input components corresponding to the arguments of the function.
* `outputs`: A list of `gradio` output components corresponding to the values returned by the function.

**`gradio.Blocks`**

For more complex and customized layouts, the `Blocks` class offers a lower-level, more flexible approach. With `Blocks`, components can be arranged explicitly using layout elements like rows and columns. It allows for the creation of multi-step workflows, where the output of one function can serve as the input to another, enabling the construction of sophisticated data applications and dashboards.

### **Key Features for Researchers**

_**Gradio**_ offers several features particularly beneficial for the research community:

* **Interactivity and Real-Time Feedback:** Allows for immediate testing of model responses to a wide variety of inputs.
* **Shareability:** Generated interfaces can be shared via a public URL, enabling easy collaboration with colleagues or stakeholders who can interact with the model from their own devices.
* **Component Variety:** Supports a wide array of data types including text, numbers, images, audio, video, dataframes, and plots.
* **Integration**: Seamlessly integrates with major machine learning libraries such as Scikit-learn, TensorFlow, and PyTorch.
* **Embedding: I**nterfaces can be directly embedded within Jupyter Notebooks, facilitating a cohesive research and development environment.

### Example One: Application in an Industrial Engineering Context

$$f$$:: Consider a scenario in quality control where a machine learning model has been trained to classify products as 'Acceptable' or 'Defective' based on sensor readings (e.g., temperature and pressure). Gradio can be used to create a simple interface for operators or engineers to test the model with new data points.

The model $$f$$ could be a trained classifier, such as a logistic regression, support vector machine, or a neural network, which computes the probability of a defect and classifies based on a threshold.

#### Python Implementation:

Assuming a simple logistic regression model has been trained and saved, the following Python code using Gradio demonstrates how to create an interactive interface for it.

```python
import gradio as gr
import numpy as np
# A mock predictive model for demonstration purposes.
# In a real scenario, one would load a pre-trained model file (e.g., a pickle file).
# Let's assume the model's decision boundary is a simple linear one.
# For example, Defect if (0.5 * temperature + 0.8 * pressure) > 100
def predict_quality(temperature, pressure):
    """
    A simple mock function to predict product quality based on sensor data.
    """
    # This simulates the model's prediction logic
    score = 0.5 * temperature + 0.8 * pressure
    if score > 100:
        return "Defective"
    else:
        return "Acceptable"

# Define the Gradio interface
iface = gr.Interface(
    fn=predict_quality,
    inputs=[
        gr.Slider(minimum=50, maximum=150, value=100, label="Temperature (Â°C)"),
        gr.Slider(minimum=80, maximum=120, value=100, label="Pressure (kPa)")
    ],
    outputs=gr.Textbox(label="Predicted Quality"),
    title="Manufacturing Quality Control",
    description="An interface to test the predictive maintenance model. Adjust the sliders to simulate sensor readings and predict product quality."
)

# Launch the interface
# This will start a local web server and can be accessed in a browser.
# In a Jupyter Notebook, the interface will be displayed inline.
iface.launch()
```

{% hint style="warning" %}
This script creates a web interface with two sliders for temperature and pressure and a textbox to display the model's prediction. An engineer can interact with the sliders to see how different operating conditions affect the predicted quality, providing an intuitive way to understand and validate the model's behavior.
{% endhint %}

***

## using VS Code

## Step 1: Environment Setup (Prerequisites)

Before writing any code, it is crucial to prepare a clean and well-configured development environment.

1. Install Python and VS Code: Ensure that a recent version of Python is installed on your system. You will also need to have Visual Studio Code installed.
2. Install the Python Extension for VS Code: Inside VS Code, navigate to the Extensions tab (Ctrl+Shift+X), search for the official Python extension by Microsoft, and install it. This extension provides essential features like linting, debugging, IntelliSense, and environment management.

#### # Step 2: Project and Virtual Environment Setup âš™ï¸

For any new project, creating a virtual environment is a best practice. It isolates your project's dependencies, preventing conflicts with other projects.

1. Create a Project Folder: On your file system, create a new folder for your application. For example: `gradio_qc_project`.
2. Open the Folder in VS Code: Launch VS Code and go to `File > Open Folder...` to open the directory you just created.
3. Create the Virtual Environment: Open a new terminal within VS Code (`Terminal > New Terminal` or `Ctrl+Shift+``). Run the following command to create a virtual environment named` venv\`:

{% hint style="success" %}
this phase assures you not to have conflicts with other projects - crc
{% endhint %}

```python
python -m venv venv
```

### Activate the Virtual Environment:&#x20;

Activation is necessary for the current terminal session to use the interpreter and libraries from this specific environment.

* On Windows:

```
.\venv\Scripts\activate
```

* On Mac

```applescript
source venv/bin/activate
```

After activation, the name of the environment (`venv`) will appear at the beginning of your terminal prompt. VS Code should also auto-detect this new environment and ask if you wish to select it as the interpreter for the workspace. Confirm this selection.

### Install Necessary Libraries

With the environment active, install Gradio and any other libraries you might need, such as `Pillow` for image manipulation.

> `Pillow` is a popular Python library used for opening, manipulating, and saving various image file formats. It is a friendly fork of the `PIL` (Python Imaging Library) and provides easy-to-use methods for image processing tasks, such as resizing, cropping, converting between formats, and enhancing images with filters. It supports many image file formats, including JPEG, PNG, BMP, and GIF, making it a versatile choice for handling images in Python applications.

To install the required libraries, you can use the following pip command in your terminal:

```bash
pip install gradio pillow
```

### Step 3: Writing the Application Code ðŸ

Now you will write the script for the application.

1. _Create the Python File:_ In the VS Code File Explorer (the left-hand panel), create a new file named `app.py`.
2. _Write the Code:_ Paste or write the application code into `app.py`. The following is a robust example of the computer vision application, wrapped in an `if __name__ == "__main__":` block. This standard practice allows the script to be importable by other modules without automatically running the web server.

```python
import gradio as gr
from PIL import Image, ImageDraw, ImageFont

def detect_defects(product_image: Image.Image):
    """
    Simulates defect detection on a product image.
    In a real-world scenario, this function would call a trained ML model.

    Args:
        product_image (PIL.Image.Image): The input image from the Gradio interface.

    Returns:
        tuple: A tuple containing the image with annotations and a diagnostic text string.
    """
    if product_image is None:
        return None, "Please upload an image."

    # Simulation of an AI model's logic
    defect_coordinates = [50, 80, 250, 180]  # [x_min, y_min, x_max, y_max]
    defect_label = "Fracture Detected"
    
    # Draw the bounding box and label on the image
    annotated_image = product_image.copy()
    draw = ImageDraw.Draw(annotated_image)
    draw.rectangle(defect_coordinates, outline="red", width=3)
    
    try:
        # Attempt to load a standard font
        font = ImageFont.truetype("arial.ttf", 20)
    except IOError:
        font = ImageFont.load_default()
    
    draw.text((defect_coordinates[0] + 5, defect_coordinates[1] - 25), 
              defect_label, fill="red", font=font)

    diagnosis = f"Diagnosis: {defect_label} at coordinates {defect_coordinates}."
    return annotated_image, diagnosis

def create_interface():
    """Creates and returns the Gradio interface object."""
    return gr.Interface(
        fn=detect_defects,
        inputs=gr.Image(type="pil", label="Upload Product Image for Analysis"),
        outputs=[
            gr.Image(label="Visual Analysis Result"),
            gr.Textbox(label="Model Diagnosis")
        ],
        title="ðŸ¤– AI Vision System for Quality Control",
        description="Platform for validating defect detection models on industrial components."
    )

# Main entry point for running the script
if __name__ == "__main__":
    interface = create_interface()
    interface.launch()  # Starts the Gradio web server
```

### Step 4: Running and Testing the Application ðŸš€

With the code in place, the next step is to run it.

**Run from the Terminal:** Ensure your virtual environment `venv` is active in the VS Code terminal. Then, simply execute the script:

```python
python app.py
```

**Observe the Output:** The terminal will display messages from Gradio, indicating that the server is running on a local URL, typically `http://127.0.0.1:7860`.

```
Running on local URL:  http://127.0.0.1:7860
Running on public URL: https://[hash].gradio.live
```

### Interact with the Application:

* _**Locally:**_ Hold down the `Ctrl` key and click the `http://127.0.0.1:7860` link in the terminal. This will open the Gradio interface in your default web browser.
* _**Sharing:**_ If you need to quickly share a prototype with a colleague who is not on your local network, you can use the public `gradio.live` URL. This link is temporary and deactivates when you stop the script.

***

### Step 5: Debugging the Application in VS Code ðŸ›

One of the most significant advantages of using an IDE like VS Code is its powerful debugging capability.

1. Set a Breakpoint: In your `app.py` file, click in the left-hand margin next to a line number inside the `detect_defects` function. For example, click next to the line `annotated_image = product_image.copy()`. A red dot will appear, indicating a breakpoint.
2. Start the Debugger: Navigate to the `Run and Debug` view (Ctrl+Shift+D) on the left-side activity bar. Click the green "Run and Debug" button and select "Python File" as the debug configuration.
3. Trigger the Breakpoint: The application will launch in debug mode. Go to the interface in your browser and upload an image. The code execution will pause at the breakpoint you set.
4. Inspect Variables: With the execution paused, you can use the debug panel in VS Code to:
   * View all local variables (like `product_image`) and their current values.
   * Inspect object properties (e.g., the size and mode of the uploaded image).
   * Step through the code line-by-line to trace the logical flow and identify errors.

This write -> run -> debug cycle within a single, unified environment dramatically accelerates the development and validation of complex, AI-driven technological solutions.
